on:
  workflow_call:
    inputs:
      container:
        type: string
        required: false
        default: 'null'
      branch_name:
        type: string
        required: true
      cache_version:
        type: string
        default: '1'
      document:
        type: boolean
        default: true
      render_readme:
        type: boolean
        default: true
      styler:
        type: boolean
        default: false
      update_cache:
        type: boolean
        default: false
    outputs:
      update_docker:
        description: "Does the docker image need update?"
        value: ${{ jobs.update-lockfile-document-render-readme-styler.outputs.update_docker }}
      commits_made:
        description: "Was a commit made?"
        value: ${{ jobs.update-lockfile-document-render-readme-styler.outputs.commits_made }}

permissions:
  contents: write
  pull-requests: write


jobs:
  update-lockfile-document-render-readme-styler:
    name: üìñ Update lockfile, document, render README, and enforce coding style
    runs-on: ubuntu-latest
    container: ${{ fromJSON(inputs.container) }}
    defaults:
      run:
        shell: bash

    outputs:
      update_docker: ${{ steps.update_docker.outputs.update_docker }}
      commits_made: ${{ steps.push_changes.outputs.commits_made }}

    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: üêû Dump github context
        run:   echo "$GITHUB_CONTEXT"
        shell: bash
        env:
         GITHUB_CONTEXT: ${{ toJson(github) }}

      - name: ‚¨áÔ∏è Checkout repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false
          ref: ${{ github.event.pull_request.head.sha }}

      - name: üîß Configure git
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

          git config --local user.name "${{ github.actor }}"
          git config --local user.email "${{ github.actor }}@users.noreply.github.com"
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks
            git remote add fork ${{ github.event.pull_request.head.repo.clone_url }}
            git remote set-url fork https://x-access-token:${{ github.token }}@github.com/${{ github.event.pull_request.head.repo.full_name }}.git
            git fetch fork ${{ github.event.pull_request.head.ref }}
            git checkout -b ${{ inputs.branch_name }} fork/${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git remote set-url origin https://$GITHUB_ACTOR:${{ secrets.GH_PAT }}@github.com/$GITHUB_REPOSITORY.git
            git switch "${{ inputs.branch_name }}"
          fi

      - name: üîß Setup Pandoc
        uses: r-lib/actions/setup-pandoc@v2

      - name: üîß Setup R
        if: ${{ inputs.container == 'null' }}
        uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true

      - name: üîß Install R dependencies
        if: ${{ inputs.container == 'null' }}
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          cache-version: ${{ inputs.cache_version }}
          extra-packages: |
            local::.
            any::pak
            any::jsonlite
            any::rcmdcheck
            any::devtools
            any::lintr
            any::covr
            any::roxygen2
            any::pkgdown
            any::rmarkdown
            any::styler
          needs: build, check, coverage, roxygen2, lint, website

      - name: üìã Update the pak.lock file
        id: pak
        run: |
          pak::lockfile_create(".", lockfile = "pak.lock", dependencies = TRUE)
          lockfile <- jsonlite::fromJSON("pak.lock")

          # Heavily filter out information
          pkg_order <- order(lockfile$packages$package)

          pak::pak(c("tibble", "dplyr"))
          print(tibble::tibble(lockfile$packages))

          lockfile$packages <- lockfile$packages[pkg_order, ] |>
            dplyr::select(dplyr::any_of(c("package", "version", "binary", "sha256")))

          jsonlite::write_json(lockfile, "pak.lock", pretty = TRUE, auto_unbox = TRUE)
        shell: Rscript {0}

      - name: ‚¨ÜÔ∏è Commit changes
        if: ${{ !cancelled() && steps.pak.conclusion == 'success' }}
        id: update_docker
        run: |
          set -o xtrace

          git stash --include-untracked

          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks - use the fork's URL and the GITHUB_TOKEN
            git pull --rebase fork ${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git pull --rebase origin ${{ inputs.branch_name }}
          fi

          git stash list | grep stash@{0} && git stash pop || echo "No stash to pop"

          lines_changed=$(git diff pak.lock | wc -l)

          if [ $lines_changed -eq 0 ]; then
            echo "update_docker=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"

            # Double check that we do not need an update
            package_match=$(Rscript -e "all(sapply(jsonlite::read_json(\"pak.lock\")\$packages, \(p) packageVersion(p\$package) == p\$version))")
            echo $package_match
            if [ "$package_match" == "[1] FALSE" ]; then
              echo "update_docker=true" >> $GITHUB_OUTPUT
              echo "Package installation mismatch detected"
            fi

          else
            echo "update_docker=true" >> $GITHUB_OUTPUT
            git add pak.lock || echo "No pak.lock to add"
            git commit -m "chore: Update pak.lock"
          fi

      - name: üìù Enforce code style
        if: ${{ !cancelled() && inputs.styler == true }}
        id: styler
        run: |
          # Set custom style
          diseasy_style <- function(...) {
            transformers <- styler::tidyverse_style(...)

            # The following spacing rules breaks our 120 placing of the # nolint tags
            transformers$space$spacing_around_op <- NULL
            transformers$space$remove_space_after_opening_paren <- NULL
            transformers$space$spacing_before_comments <- NULL

            # The "remove_line_break_in_fun_call" rule works poorly with R6 classes
            # and condenses the the entire codebase to an unreadable level.
            transformers$line_break$remove_line_break_in_fun_call <- NULL

            # The "style_line_break_around_curly" rule in general
            # removes spacing that helps readability.
            transformers$line_break$style_line_break_around_curly <- NULL

            transformers
          }

          styler::style_pkg(style = diseasy_style)
        shell: Rscript {0}

      - name: ‚¨ÜÔ∏è Commit changes
        if: ${{ !cancelled() && steps.styler.conclusion == 'success' && inputs.styler == true }}
        run: |
          git stash --include-untracked

          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks - use the fork's URL and the GITHUB_TOKEN
            git pull --rebase fork ${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git pull --rebase origin ${{ inputs.branch_name }}
          fi

          git stash list | grep stash@{0} && git stash pop || echo "No stash to pop"
          git add *.R && git add *.Rmd
          git commit -m "chore: Enforce code style" || echo "No changes to commit"

      - name: üìñ Document
        if: ${{ !cancelled() && inputs.document == true }}
        id: document
        run: roxygen2::roxygenise()
        shell: Rscript {0}

      - name: ‚¨ÜÔ∏è Commit changes
        if: ${{ !cancelled() && steps.document.conclusion == 'success' && inputs.document == true }}
        run: |
          git stash --include-untracked

          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks - use the fork's URL and the GITHUB_TOKEN
            git pull --rebase fork ${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git pull --rebase origin ${{ inputs.branch_name }}
          fi

          git stash list | grep stash@{0} && git stash pop || echo "No stash to pop"
          git add man/\* NAMESPACE DESCRIPTION
          git commit -m "docs: Re-build roxygen documentation" || echo "No changes to commit"

      - name: üîß Setup Node
        if: ${{ !cancelled() && inputs.render_readme == true && inputs.container != 'null' }}
        run: |
          sudo apt-get -y install nodejs
          sudo apt-get -y install npm

      - name: üîß Install nunjucks
        if: ${{ !cancelled() && inputs.render_readme == true }}
        run: npm install nunjucks

      - name: üîÄ Resolve nunjucks templates
        if: ${{ !cancelled() && inputs.render_readme == true }}
        run: |
          echo "
            const nunjucks = require('nunjucks');
            const fs = require('node:fs');

            nunjucks.configure({ autoescape: true, trimBlocks: true, lstripBlocks: true });

            var res = nunjucks.render('README.Rmd', {repo_name: '${{ github.event.repository.name }}'});

            fs.writeFile('README.Rmd', res, (err) => err && console.error(err));" >> render-templates.js
          node render-templates.js

      - name: üìñ Render README
        if: ${{ !cancelled() && inputs.render_readme == true }}
        id: readme
        run: rmarkdown::render("README.Rmd")
        shell: Rscript {0}

      - name: ‚¨ÜÔ∏è Commit changes
        if: ${{ !cancelled() && steps.readme.conclusion == 'success' && inputs.render_readme == true }}
        run: |
          git stash --include-untracked

          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks - use the fork's URL and the GITHUB_TOKEN
            git pull --rebase fork ${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git pull --rebase origin ${{ inputs.branch_name }}
          fi

          git stash list | grep stash@{0} && git stash pop || echo "No stash to pop"
          git add README.md
          git commit -m "docs(README): Re-build README.Rmd" || echo "No changes to commit"

      - name: ‚öôÔ∏è Update vignette caches
        if: ${{ !cancelled() && inputs.update_cache == true }}
        id: vignette
        run: |
          # Load development state
          devtools::load_all()

          # Look for cached files
          cached_files <- list.files(
            file.path("vignettes"),
            pattern = ".rds",
            recursive = TRUE,
            full.names = TRUE
          )

          # Infer the vignettes that need to be re-rendered
          vignettes_with_cache <- unique(basename(dirname(cached_files)))

          vignettes <- list.files(
            file.path("vignettes"),
            pattern = ".Rmd",
            recursive = TRUE,
            full.names = TRUE
          ) |>
            purrr::keep(~ stringr::str_extract(basename(.), r"{[^\.]+}") %in% vignettes_with_cache)

          # Run each vignette to update the cache
          for (vignette in vignettes) {
            rmarkdown::render(vignette)
          }
        shell: Rscript {0}

      - name: ‚¨ÜÔ∏è Commit changes
        if: ${{ !cancelled() && steps.vignette.conclusion == 'success' && inputs.update_cache == true }}
        run: |
          git stash --include-untracked

          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks - use the fork's URL and the GITHUB_TOKEN
            git pull --rebase fork ${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git pull --rebase origin ${{ inputs.branch_name }}
          fi

          git stash list | grep stash@{0} && git stash pop || echo "No stash to pop"
          git add *.rds || echo "No .rds cache files to add"
          git commit -m "chore(vignettes): Update the cache" || echo "No changes to commit"

      - name: üöÄ Push changes
        if: ${{ !cancelled() }}
        id: push_changes
        run: |
          set -o xtrace

          # Check if any commits have been made
          export BRANCH_A=${{ inputs.branch_name }}
          export BRANCH_B=origin/${{ inputs.branch_name }}

          if [ x"$(git rev-parse $BRANCH_A)" = x"$(git rev-parse $BRANCH_B)" ]
          then
              echo $BRANCH_A and $BRANCH_B are the same - no commits made
              echo "commits_made=false" >> $GITHUB_OUTPUT
          else
              echo $BRANCH_A and $BRANCH_B differ - commits detected
              echo "commits_made=true" >> $GITHUB_OUTPUT
          fi



          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            # For PRs from forks - use the fork's URL and the GITHUB_TOKEN
            git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.event.pull_request.head.repo.owner.login }}/${{ github.event.pull_request.head.repo.name }}.git HEAD:${{ github.event.pull_request.head.ref }}
          else
            # For PRs from the same repository
            git push origin ${{ inputs.branch_name }}
          fi
